<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>縁日射的ゲーム</title>
    <style>
        /* CSS Reset and Basic Layout */
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #222;
            font-family: 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif;
            color: white;
            
            /* Enhanced Mobile Interactions - Prevent selection and zoom */
            touch-action: none; /* Prevent browser zooming/scrolling */
            -webkit-touch-callout: none; /* Prevent long press menu on iOS */
            -webkit-user-select: none; /* Safari/Chrome prevent text select */
            -moz-user-select: none; /* Firefox */
            -ms-user-select: none; /* IE/Edge */
            user-select: none; /* Standard */
            -webkit-tap-highlight-color: transparent; /* Remove tap highlight color */

            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* Game Container */
        #game-container {
            position: relative;
            flex-grow: 1;
            width: 100%;
            background: #e0d0b0; /* Wooden wall color */
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Canvas */
        canvas {
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            background: url('data:image/svg+xml;utf8,<svg width="20" height="100" xmlns="http://www.w3.org/2000/svg"><rect width="20" height="100" fill="%23dcc6a0"/><rect width="1" height="100" fill="%23c0aa80"/></svg>'); /* Wood texture pattern */
        }

        /* UI Overlay (Score, Ammo) */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            text-shadow: 2px 2px 0 #000;
            z-index: 10;
        }

        .ui-box {
            background: rgba(180, 0, 0, 0.8); /* Festival Red */
            padding: 5px 15px;
            border-radius: 8px;
            border: 2px solid #fff;
            font-size: 18px;
            font-weight: bold;
        }

        /* Virtual Controls Container */
        #controls {
            height: 220px;
            background: #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 40px;
            box-sizing: border-box;
            border-top: 4px solid #b40000;
        }

        /* D-Pad Styles - Updated for separate square buttons */
        .d-pad {
            position: relative;
            width: 150px;
            height: 150px;
        }

        .d-btn {
            position: absolute;
            background: #555;
            border: 2px solid #777;
            border-radius: 6px; /* Slightly rounded */
            cursor: pointer;
            touch-action: manipulation;
            width: 48px; /* Square size */
            height: 48px; /* Square size */
            box-sizing: border-box;
            box-shadow: 0 4px 0 #333;
        }
        .d-btn:active, .d-btn.active { 
            background: #888; 
            border-color: #aaa; 
            transform: translateY(2px);
            box-shadow: 0 2px 0 #333;
        }

        /* Positioning buttons in a cross shape with slight gap */
        .d-up { top: 0; left: 51px; }
        .d-down { top: 102px; left: 51px; }
        .d-left { top: 51px; left: 0; }
        .d-right { top: 51px; left: 102px; }

        /* Icons for D-pad */
        .d-btn::after {
            content: '';
            position: absolute;
            top: 50%; left: 50%;
            border: solid #ccc;
            border-width: 0 3px 3px 0;
            display: inline-block;
            padding: 3px;
        }
        .d-up::after { transform: translate(-50%, -30%) rotate(-135deg); }
        .d-down::after { transform: translate(-50%, -70%) rotate(45deg); }
        .d-left::after { transform: translate(-30%, -50%) rotate(135deg); }
        .d-right::after { transform: translate(-70%, -50%) rotate(-45deg); }


        /* Fire Button Styles */
        #fire-btn {
            width: 100px;
            height: 100px;
            background: #e63946;
            border: 4px solid #fff;
            border-radius: 50%;
            color: white;
            font-size: 20px;
            font-weight: bold;
            box-shadow: 0 4px 0 #8a1c25;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
            -webkit-user-select: none;
        }
        #fire-btn:active {
            transform: translateY(4px);
            box-shadow: none;
            background: #ff5a66;
        }

        /* Start/Game Over Overlay */
        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            color: white;
            text-align: center;
        }
        #overlay h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #ffcc00;
            text-shadow: 2px 2px #b40000;
            letter-spacing: 5px;
        }
        #start-btn {
            padding: 15px 40px;
            font-size: 24px;
            background: #b40000;
            color: white;
            border: 2px solid white;
            border-radius: 50px;
            cursor: pointer;
            font-weight: bold;
        }

        /* Lantern decorations */
        .lantern {
            position: absolute;
            top: 10px;
            width: 30px;
            height: 40px;
            background: radial-gradient(circle, #ff6666 0%, #cc0000 100%);
            border-radius: 10px;
            box-shadow: 0 0 10px #ff6666;
            z-index: 5;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <!-- Decorative Lanterns -->
        <div class="lantern" style="left: 10%"></div>
        <div class="lantern" style="left: 30%"></div>
        <div class="lantern" style="left: 50%"></div>
        <div class="lantern" style="left: 70%"></div>
        <div class="lantern" style="left: 90%"></div>

        <div id="ui-layer">
            <div class="ui-box">点数: <span id="score-display">0</span></div>
            <div class="ui-box">残り弾: <span id="ammo-display">10</span></div>
        </div>
        
        <canvas id="gameCanvas"></canvas>

        <div id="overlay">
            <h1>縁日射的</h1>
            <p style="margin-bottom: 20px; font-size: 14px; opacity: 0.8;">
                十字キーで狙いを定めて、<br>
                発射ボタンで撃ち落とせ！<br>
                照準は常に揺れるぞ。<br>
            </p>
            <button id="start-btn">ゲーム開始</button>
        </div>
    </div>

    <!-- Controls -->
    <div id="controls">
        <div class="d-pad">
            <div class="d-btn d-up" data-dir="up"></div>
            <div class="d-btn d-left" data-dir="left"></div>
            <!-- Removed center element -->
            <div class="d-btn d-right" data-dir="right"></div>
            <div class="d-btn d-down" data-dir="down"></div>
        </div>
        
        <div id="fire-btn">発射</div>
    </div>

    <script>
        /**
         * Sound Manager using Web Audio API
         * Generates synthesized sounds to avoid external asset dependencies.
         */
        class SoundManager {
            constructor() {
                this.ctx = null;
                this.initialized = false;
            }

            init() {
                if (!this.initialized) {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.ctx = new AudioContext();
                    this.initialized = true;
                }
                // Resume context if suspended (browser policy)
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            }

            // "Pop" sound for shooting cork
            playShoot() {
                if (!this.initialized) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = 'triangle';
                osc.frequency.setValueAtTime(150, t);
                osc.frequency.exponentialRampToValueAtTime(600, t + 0.1);

                gain.gain.setValueAtTime(0.5, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);

                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start(t);
                osc.stop(t + 0.15);
            }

            // "Clack" sound for hitting a prize
            playHit() {
                if (!this.initialized) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = 'square';
                osc.frequency.setValueAtTime(200, t);
                osc.frequency.exponentialRampToValueAtTime(50, t + 0.1);

                gain.gain.setValueAtTime(0.3, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);

                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start(t);
                osc.stop(t + 0.1);
            }

            // Empty click if out of ammo
            playEmpty() {
                if (!this.initialized) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(800, t);
                gain.gain.setValueAtTime(0.1, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.05);

                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start(t);
                osc.stop(t + 0.05);
            }
        }

        /**
         * Game Logic
         */
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score-display');
        const ammoEl = document.getElementById('ammo-display');
        const startBtn = document.getElementById('start-btn');
        const overlay = document.getElementById('overlay');
        const fireBtn = document.getElementById('fire-btn');

        // Initial Dimensions
        let width, height;
        
        // Game State
        const state = {
            isPlaying: false,
            score: 0,
            ammo: 10,
            lastTime: 0,
            prizes: [],
            particles: [], // For hit effects
            vendor: null, // The stall vendor
            vendorDefeated: false
        };

        // Aiming State
        const aim = {
            x: 0,
            y: 0,
            baseX: 0, // Position without sway
            baseY: 0,
            speed: 200, // Pixels per second (Slow movement)
            swayTime: 0,
            swayAmount: 20, // Amplitude of jitter
        };

        // Input State
        const input = {
            up: false,
            down: false,
            left: false,
            right: false
        };

        const sound = new SoundManager();

        // Resize handling
        function resize() {
            width = canvas.parentElement.clientWidth;
            height = canvas.parentElement.clientHeight;
            canvas.width = width;
            canvas.height = height;
            // Center aim on resize
            if (!state.isPlaying) {
                aim.baseX = width / 2;
                aim.baseY = height / 2;
            }
        }
        window.addEventListener('resize', resize);
        resize();

        /**
         * Vendor (The "Tekiya" Uncle) Definition
         */
        class Vendor {
            constructor(y) {
                this.w = 80;
                this.h = 100;
                this.x = -this.w; // Start off-screen left
                this.y = y;
                this.speed = 100; // Pixels per second
                this.hp = 5; // Hits required to defeat
                this.active = true;
                this.color = '#e74c3c'; // Reddish color for the vendor
                this.direction = 1; // 1 for right, -1 for left
                this.appearing = false;
                this.appearTimer = 0;
            }

            draw(ctx) {
                if (!this.active || !this.appearing) return;

                ctx.save();
                ctx.translate(this.x, this.y);

                // Vendor Body/Face
                ctx.fillStyle = '#f1c40f'; // Skin tone
                ctx.fillRect(this.w * 0.2, this.h * 0.1, this.w * 0.6, this.h * 0.4); // Face
                ctx.fillStyle = this.color;
                ctx.fillRect(0, this.h * 0.5, this.w, this.h * 0.5); // Shirt

                // Vendor Features (Simple)
                ctx.fillStyle = '#333';
                ctx.fillRect(this.w * 0.3, this.h * 0.2, 10, 10); // Eye L
                ctx.fillRect(this.w * 0.6, this.h * 0.2, 10, 10); // Eye R
                ctx.fillRect(this.w * 0.3, this.h * 0.35, this.w * 0.4, 5); // Mouth

                // HP Indicator (Bandana/Hachimaki)
                ctx.fillStyle = '#fff';
                ctx.fillRect(this.w * 0.1, this.h * 0.05, this.w * 0.8, 15);
                ctx.fillStyle = 'red';
                for (let i = 0; i < this.hp; i++) {
                    ctx.beginPath();
                    ctx.arc(this.w * 0.2 + i * 12, this.h * 0.125, 4, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }

            update(dt) {
                if (!this.active) return;

                if (this.appearing) {
                    this.x += this.speed * this.direction * dt;

                    // Check if off-screen and reset
                    if ((this.direction === 1 && this.x > width) || (this.direction === -1 && this.x + this.w < 0)) {
                        this.appearing = false;
                        this.appearTimer = Math.random() * 3 + 2; // Random delay before reappearing (2-5s)
                    }
                } else {
                    this.appearTimer -= dt;
                    if (this.appearTimer <= 0) {
                        this.appearing = true;
                        this.direction = Math.random() > 0.5 ? 1 : -1;
                        this.x = this.direction === 1 ? -this.w : width;
                        
                        // Randomize Y position (Keep within 20% to 80% of screen height)
                        this.y = (height * 0.2) + Math.random() * (height * 0.6);
                    }
                }
            }

            hit() {
                this.hp--;
                if (this.hp <= 0) {
                    this.active = false;
                    return true; // Defeated
                }
                return false; // Not yet defeated
            }
        }

        /**
         * Prize Definition
         */
        class Prize {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.w = 50;
                this.h = 60;
                this.type = type; // 'card', 'box', 'doll'
                this.active = true;
                this.rotation = 0;
                this.fallSpeed = 0;
                
                // Set score and visual properties based on type
                if (type === 'card') {
                    this.score = 50;
                    this.color = '#fff';
                    this.h = 70;
                    this.w = 40;
                } else if (type === 'box') {
                    this.score = 100;
                    this.color = '#4ecdc4';
                    this.w = 60;
                } else if (type === 'doll') {
                    this.score = 200;
                    this.color = '#ff6b6b';
                    this.w = 40;
                    this.h = 50;
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x + this.w/2, this.y + this.h/2);
                ctx.rotate(this.rotation);
                
                if (this.active) {
                    // Draw Prize Standing
                    ctx.fillStyle = this.color;
                    ctx.fillRect(-this.w/2, -this.h/2, this.w, this.h);
                    
                    // Detail based on type
                    ctx.fillStyle = 'rgba(0,0,0,0.2)';
                    if (this.type === 'card') {
                        ctx.beginPath();
                        ctx.arc(0, -10, 10, 0, Math.PI*2);
                        ctx.fill();
                    } else if (this.type === 'box') {
                        ctx.fillRect(-this.w/2 + 5, -this.h/2 + 5, this.w-10, this.h-10);
                    } else if (this.type === 'doll') {
                        ctx.beginPath();
                        ctx.arc(0, -this.h/2, 15, 0, Math.PI*2); // Head
                        ctx.fill();
                    }
                    
                    // Price tag
                    ctx.fillStyle = 'white';
                    ctx.fillRect(-10, this.h/2 - 15, 20, 10);
                    ctx.fillStyle = 'black';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(this.score, 0, this.h/2 - 7);

                } else {
                    // Draw Prize Fallen
                    ctx.fillStyle = '#555'; // Shadow/Darkened
                    ctx.fillRect(-this.w/2, -this.h/2, this.w, this.h);
                }
                ctx.restore();
            }

            update(dt) {
                if (!this.active) {
                    // Fall animation
                    this.fallSpeed += 500 * dt; // Gravity
                    this.y += this.fallSpeed * dt;
                    this.rotation += 2 * dt;
                }
            }
        }

        // Particle effect for hits
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 300;
                this.vy = (Math.random() - 0.5) * 300;
                this.life = 1.0;
                this.color = color;
            }
            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.life -= 2 * dt;
            }
            draw(ctx) {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 3, 0, Math.PI*2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        function initGame() {
            state.score = 0;
            state.ammo = 10;
            state.prizes = [];
            state.particles = [];
            state.vendorDefeated = false;
            scoreEl.innerText = state.score;
            ammoEl.innerText = state.ammo;
            
            aim.baseX = width / 2;
            aim.baseY = height / 2;
            
            // Setup Shelves
            const shelfYPositions = [height * 0.3, height * 0.55, height * 0.8];
            
            shelfYPositions.forEach((sy) => {
                const count = Math.floor(width / 80);
                for(let i=1; i<count; i++) {
                    const typeRoll = Math.random();
                    let type = 'card';
                    if (typeRoll > 0.6) type = 'box';
                    if (typeRoll > 0.9) type = 'doll';
                    
                    // Add some randomness to position
                    const px = (i * 80) + (Math.random() * 20 - 10);
                    // Place prize on shelf (y is top-left, so subtract height)
                    const p = new Prize(px, sy - 70, type); // 70 is rough height buffer
                    state.prizes.push(p);
                }
            });

            // Initialize Vendor (places him between shelves)
            state.vendor = new Vendor(height * 0.4);
            state.vendor.appearTimer = 2.0; // Initial delay

            state.isPlaying = true;
            state.lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        }

        function fire() {
            if (!state.isPlaying) return;
            
            if (state.ammo <= 0) {
                sound.playEmpty();
                return;
            }

            state.ammo--;
            ammoEl.innerText = state.ammo;
            sound.playShoot();

            // Collision Detection
            // Using aim.x/y which includes the sway
            let hit = false;

            // Check collision with Vendor first
            const v = state.vendor;
            if (v.active && v.appearing &&
                aim.x >= v.x && aim.x <= v.x + v.w &&
                aim.y >= v.y && aim.y <= v.y + v.h) {
                
                hit = true;
                sound.playHit();
                
                // Spawn particles
                for(let k=0; k < 8; k++) {
                    state.particles.push(new Particle(aim.x, aim.y, v.color));
                }

                if (v.hit()) {
                    // Vendor Defeated!
                    state.vendorDefeated = true;
                    state.score += 1000; // Bonus score for defeating vendor
                    scoreEl.innerText = state.score;

                    // Clear all prizes
                    state.prizes.forEach(p => {
                        if (p.active) {
                            p.active = false;
                            state.score += p.score;
                            // Spawn particles for each prize cleared
                            for(let k=0; k < 5; k++) {
                                state.particles.push(new Particle(p.x + p.w/2, p.y + p.h/2, p.color));
                            }
                        }
                    });
                    scoreEl.innerText = state.score;
                    
                    setTimeout(() => {
                        endGame("おじさん撃破！景品全取り！");
                    }, 1500);
                    return; // Stop further checks
                }
            }
            
            // If vendor not hit, check prizes
            if (!hit) {
                // Iterate backwards to hit front prizes first if overlapping (simple Z-order)
                for (let i = state.prizes.length - 1; i >= 0; i--) {
                    const p = state.prizes[i];
                    if (!p.active) continue;

                    // Simple AABB collision with aim point
                    if (aim.x >= p.x && aim.x <= p.x + p.w &&
                        aim.y >= p.y && aim.y <= p.y + p.h) {
                        
                        p.active = false;
                        state.score += p.score;
                        scoreEl.innerText = state.score;
                        sound.playHit();
                        hit = true;

                        // Spawn particles
                        for(let k=0; k<8; k++) {
                            state.particles.push(new Particle(aim.x, aim.y, p.color));
                        }
                        break; // Bullet hits one item
                    }
                }
            }

            if (!hit) {
                 // Miss effect (small gray puff)
                 for(let k=0; k<3; k++) {
                    state.particles.push(new Particle(aim.x, aim.y, '#ccc'));
                }
            }

            if (state.ammo === 0 && !state.vendorDefeated) {
                setTimeout(() => {
                    endGame("弾切れ終了！");
                }, 1000);
            }
        }

        function endGame(message) {
            state.isPlaying = false;
            overlay.style.display = 'flex';
            document.querySelector('#overlay h1').innerText = message || "終了！";
            document.querySelector('#overlay p').innerHTML = `最終スコア: <span style="font-size:32px; color:#ffcc00">${state.score}</span> 点`;
            startBtn.innerText = "もう一度遊ぶ";
        }

        /**
         * Main Game Loop
         */
        function gameLoop(timestamp) {
            if (!state.isPlaying) return;

            const dt = (timestamp - state.lastTime) / 1000;
            state.lastTime = timestamp;

            update(dt, timestamp);
            render();

            requestAnimationFrame(gameLoop);
        }

        function update(dt, time) {
            // 1. Aim Movement (Slow, heavy feel)
            const moveSpeed = aim.speed * dt;
            if (input.up) aim.baseY -= moveSpeed;
            if (input.down) aim.baseY += moveSpeed;
            if (input.left) aim.baseX -= moveSpeed;
            if (input.right) aim.baseX += moveSpeed;

            // Clamp to screen
            aim.baseX = Math.max(0, Math.min(width, aim.baseX));
            aim.baseY = Math.max(0, Math.min(height, aim.baseY));

            // 2. Aim Sway (Perlin-like noise using sine waves)
            // Simulates breathing/unsteady hands
            aim.swayTime += dt;
            const t = aim.swayTime;
            
            // Combine multiple sine waves for organic drift
            const driftX = Math.sin(t * 1.5) * aim.swayAmount * 0.6 + Math.cos(t * 3.2) * aim.swayAmount * 0.4;
            const driftY = Math.cos(t * 1.8) * aim.swayAmount * 0.6 + Math.sin(t * 2.5) * aim.swayAmount * 0.4;

            // Calculate actual aim position
            aim.x = aim.baseX + driftX;
            aim.y = aim.baseY + driftY;

            // 3. Update Vendor
            state.vendor.update(dt);

            // 4. Update Prizes
            state.prizes.forEach(p => p.update(dt));

            // 5. Update Particles
            for (let i = state.particles.length - 1; i >= 0; i--) {
                state.particles[i].update(dt);
                if (state.particles[i].life <= 0) {
                    state.particles.splice(i, 1);
                }
            }
        }

        function render() {
            // Clear Background
            ctx.clearRect(0, 0, width, height);

            // Draw Shelves
            ctx.fillStyle = '#8b4513'; // SaddleBrown
            const shelfYPositions = [height * 0.3, height * 0.55, height * 0.8];
            shelfYPositions.forEach(y => {
                ctx.fillRect(0, y, width, 20); // Shelf plank
                // Shelf shadow
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.fillRect(0, y+20, width, 5);
                ctx.fillStyle = '#8b4513'; // Reset
            });

            // Draw Prizes
            state.prizes.forEach(p => p.draw(ctx));

            // Draw Vendor (in front of prizes)
            state.vendor.draw(ctx);

            // Draw Particles
            state.particles.forEach(p => p.draw(ctx));

            // Draw Crosshair (Sight)
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(aim.x, aim.y, 25, 0, Math.PI * 2);
            ctx.stroke();

            // Cross lines
            ctx.beginPath();
            ctx.moveTo(aim.x - 35, aim.y);
            ctx.lineTo(aim.x + 35, aim.y);
            ctx.moveTo(aim.x, aim.y - 35);
            ctx.lineTo(aim.x, aim.y + 35);
            ctx.stroke();

            // Inner dot
            ctx.fillStyle = 'red';
            ctx.beginPath();
            ctx.arc(aim.x, aim.y, 3, 0, Math.PI * 2);
            ctx.fill();
        }

        /**
         * Input Handling
         */
        
        // Keyboard Support
        window.addEventListener('keydown', (e) => {
            if (e.repeat) return;
            switch(e.key) {
                case 'ArrowUp': input.up = true; break;
                case 'ArrowDown': input.down = true; break;
                case 'ArrowLeft': input.left = true; break;
                case 'ArrowRight': input.right = true; break;
                case ' ': // Spacebar
                case 'Enter':
                    fire();
                    break;
            }
        });

        window.addEventListener('keyup', (e) => {
            switch(e.key) {
                case 'ArrowUp': input.up = false; break;
                case 'ArrowDown': input.down = false; break;
                case 'ArrowLeft': input.left = false; break;
                case 'ArrowRight': input.right = false; break;
            }
        });

        // Touch/Mouse Support for D-pad
        const dpadBtns = document.querySelectorAll('.d-btn');
        
        const handleInputStart = (dir) => {
            if (dir && input.hasOwnProperty(dir)) {
                input[dir] = true;
                // Vibration feedback if supported
                if (navigator.vibrate) navigator.vibrate(5);
            }
        };

        const handleInputEnd = (dir) => {
            if (dir && input.hasOwnProperty(dir)) {
                input[dir] = false;
            }
        };

        dpadBtns.forEach(btn => {
            const dir = btn.dataset.dir;
            
            // Touch events
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                btn.classList.add('active');
                handleInputStart(dir);
            });
            btn.addEventListener('touchend', (e) => {
                e.preventDefault();
                btn.classList.remove('active');
                handleInputEnd(dir);
            });

            // Mouse events for PC debugging
            btn.addEventListener('mousedown', (e) => {
                btn.classList.add('active');
                handleInputStart(dir);
            });
            btn.addEventListener('mouseup', (e) => {
                btn.classList.remove('active');
                handleInputEnd(dir);
            });
            btn.addEventListener('mouseleave', (e) => {
                btn.classList.remove('active');
                handleInputEnd(dir);
            });
        });

        // Fire Button
        fireBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            fire();
        });
        fireBtn.addEventListener('mousedown', (e) => {
            e.preventDefault();
            fire();
        });

        // Start Button
        startBtn.addEventListener('click', () => {
            sound.init(); // Must be user triggered
            overlay.style.display = 'none';
            initGame();
        });

    </script>
</body>
</html>


